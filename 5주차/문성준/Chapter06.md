# ch06 스프링이 사랑한 디자인패턴 DDD

---

---

객체지향 특성은 도구로, 설계 원칙은 도구를 올바르게 사용하는 방법이다.
(객체지향 특성 - 캡 ! 상추다, 설계 원칙 - SOLID)

디자인(설계) 패턴 - 레시피
설계 원칙 - 요리도구 사용법, 캡! 상추다 - 요리도구

**스프링**

- 스프링 프레임 워크는 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크다.

> “ OOP 프레임워크 ”
객체 지향의 특성과  설계 원칙을 극한까지 적용한 프레임워크이며,
스프링에서 시작해 객체 지향으로 향하는 하향식 학습이든 어떠한 학습이든 꼭 스프링을 만나보자.
> 
- 실무에서는 영문 이름으로 패턴을 사용하기 때문에, 패턴을 이해했다면 꼭 영문 이름으로 기억해 두자.

---

# Adapter Pattern

> 호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴
> 
- 변환기라고 할 수 있다. 서로 다른 두 인터페이스 사이에 통신이 가능하게 하는 것이다. (예 : 충전기)
- 다양한 DB 시스템을 공통의 인터페이스인 ODBC 또는 JDBC를 이용해 조작할 수 있다.
- ODBC/JDBC가 **Adapter Pattern**을 이용해 다양한 데이터베이스 시스템을 단일화 인터페이스로 조작할 수 있게 해주기 때문이다.

→ **Adapter Pattern**은 개방 폐쇄 원칙(OCP)을 활용한 설계 패턴이라고 할 수도 있다.

- 어댑터 패턴을 적용해 메서드명을 통일할 수도 있다. 
→ 동일 이름의 메서드로 호출해서 사용할 수 있게 해주는 변환기다.
- **Adapter Pattern**은 합성,
 즉 객체를 속성으로 만들어서 참조하는 디자인 패턴이다.

---

# Proxy Pattern

프록시는 대리자, 대변인이라는 뜻.

> 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴
> 
- 실제 서비스 객체가 가진 메서드와 같은 이름의 메서드를 사용하는데, 이를 위해 인터페이스 사용.
- 인터페이스를 사용하면서 서비스 객체가 들어갈 자리에 대리자 객체를 대신 투입해 클라이언트 쪽에서는 실제 서비스 객체를 통해 메서드를 호출하고 반환값을 받는지, 대리자 객체를 통해 메서드를 호출하고 반환값을 받는지 전혀 모르게 처리할 수도 있다.
- 예제에 객체 생성이란 것을 한다. 이해되지 않을 분들을 위해 이해하기 쉽도록 설명하겠다.
    - `IService proxy = new Proxy();` → Proxy 인스턴스를 생성한 후, 생성된 Proxy 인스턴스의 주소를 `proxy`라는 참조변수에 저장. 여기서 중요한 점은 `proxy` 참조변수는 `IService`라는 클래스 타입을 갖는다. 이는 `Proxy` 클래스가 `IService` 인터페이스를 구현하고 있음을 의미.
    `proxy` 변수는 `IService` 인터페이스에 정의된 모든 메서드를 호출할 수 있으며, 다형성 실현 가능.
    즉, new 연산자는 객체를 생성해주는 역할을하며, 힙 영역에 데이터를 저장할 공간을 할당받고, 그 공간의 참조값을 객체엑 반환하여 주고 이어서 생성자를 호출한다.
    - 간단히 말해, `IService` 인터페이스 타입의 `proxy` 참조 변수를 통해 `Proxy` 인스턴스를 다룰 수 있게 되며, 이를 통해 구현된 메서드에 접근할 수 있다.
- 간단한 코드이니, 코드 해석은 하지 않겠다.

### 프록시 패턴의 중요 포인트

- 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
- 대리자는 실제 서비스에 대한 참조 변수를 갖는다(합성)
- 대리자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 ㄱ밧을 클라이언트에게 반환한다.
- 대리자는 실제 서비스의 메서드 호출 전 후에 별도의 로직을 수행할 수도 있다.

---

# Decorator Pattern

> 메서드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 패턴
> 

프록시 패턴과 구현 방법이 같으며, 원본에 장식을 더하는 패턴.

다만, **프록시 패턴**은 클라이언트가 최종적으로 돌려 받는 반환값을 조작하지 않고 그대로 전달.

반면, **데코레이터 패턴**은 클라이언트가 받는 반환값에 장식을 덧입힌다.

### 중요 포인트

- 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
- 장식자는 실제 서비스에 대한 참조 변수를 갖는다(합성).
- 장식자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고, 그 반환값에 장식을 더해 클라이언트에게 반환.
- 장식자는 실제 서비스의 메서드 호출 전 후에 별도의 로직을 수행할 수도 있다.

실제 서비스의 반환 값을 예쁘게(?) 포장(장식)하는 패턴이 데코레이터 패턴이다.

---

# Singleton Pattern

> 클래스의 인스턴스, 즉 객체를 하나만 만들어 사용하는 패턴
> 

인스턴스를 하나만 만들어 사용하기 위한 패턴.

커넥션 풀, 스레드 풀, 디바이스 설정 객체 등과 같은 경우 인스턴스를 여러 개 만들게 되면 불필요한 자원을 사용하게 되고, 프로그램이 예상치 못한 결과를 낳을 수 있다.
반면, 해당 패턴은 오직 인스턴스를 하나만 만들고 그것을 계속해서 재사용한다.

싱글턴 패턴을 적용할 경우 의미상 두 개의 객체가 존재할 수 없다.

객체 생성을 위한 new에 제약을 걸어야 하고, 만들어진 단일 객체를 반환할 수 있는 메서드가 필요.

### 반드시 필요한 요소 3가지

- new를 실행할 수 없도록 **생성자에 private 접근 제어자를 지정**.
- 유일한 단일 객체를 반환할 수 있는 **정적 메서드가 필요**.
- 유일한 단일 객체를 참조할 **정적 참조 변수가 필요**.

싱글턴 패턴의 힘은, 
단일 객체인 경우 결국 공유 객체로 사용되기 때문에 속성을 갖지 않게 하는 것이 정석이다.
단일 객체가 속성을 갖게 되면 하나의 참조 변수가 변경한 단일 객체의 속성이 다른 참조 변수에 영향을 미치기 때문이다. 이는 전역/공유 변수를 가능한 한 사용하지 말라는 지침과 일맥상통한다.

다만 읽기 전용 속성을 갖는 것은 문제가 되지 않는다.(WHY ?)

이와 더불어, 단일 객체가 다른 단일 객체에 대한 참조를 속성으로 가진 것 또한 문제가 되지 않는다(why?, how?) → 이는 **스프링의 싱글턴 빈이 가져야 할 제약조건**이다.

### Singleton Pattern 특징

- private 생성자를 갖는다.
- 단일 객체 참조 변수를 정적 속성으로 갖는다.
- 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적 메서드를 갖는다.
- 단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다.

---

# Starategey Pattern

> 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴
> 

전략 패턴은 디자인 패턴의 꽃이다.

### 전략 패턴을 구성하는 세 요소

- 전략 메서드를 가진 전략 객체
- 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
- 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자)

클라이언트는 다양한 전략 중 하나를 선택해 생성한 후 컨텍스트에 주입함.

군인이 있다고 가정하고, 전략 패턴에 따라 구분해 보면
무기 = 전략, 군인 = 컨텍스트, 보급 장교 = 제 3자 (클라이언트)가 된다.

```java
// 전략 인터페이스
public interface WeaponStrategy {
    void useWeapon();
}

// 구체적인 전략 클래스들
public class Gun implements WeaponStrategy {
    @Override
    public void useWeapon() {
        System.out.println("Using a gun to shoot.");
    }
}

public class Rifle implements WeaponStrategy {
    @Override
    public void useWeapon() {
        System.out.println("Using a rifle for long-range shots.");
    }
}

public class Grenade implements WeaponStrategy {
    @Override
    public void useWeapon() {
        System.out.println("Throwing a grenade.");
    }
}
```

```java
// 컨텍스트 클래스
public class Soldier {
    private WeaponStrategy weaponStrategy;

    // 무기 전략을 설정하는 메서드
    public void setWeaponStrategy(WeaponStrategy weaponStrategy) {
        this.weaponStrategy = weaponStrategy;
    }

    // 무기 사용
    public void useWeapon() {
        if (weaponStrategy != null) {
            weaponStrategy.useWeapon();
        } else {
            System.out.println("No weapon assigned.");
        }
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Soldier soldier = new Soldier();

        // 군인에게 총을 사용하도록 설정
        soldier.setWeaponStrategy(new Gun());
        soldier.useWeapon();

        // 상황에 따라 무기를 라이플로 변경
        soldier.setWeaponStrategy(new Rifle());
        soldier.useWeapon();

        // 추가로 수류탄 사용으로 변경
        soldier.setWeaponStrategy(new Grenade());
        soldier.useWeapon();
    }
}
```

메서드 패턴과 유사하다는 느낌이 든다면, 제대로 본 것이다.

상속을 이용하는 템플릿 메서드 패턴과 객체 주입을 통한 전략 패턴 중에 선택/적용할 수 있다.

단일 상속만이 가능한 자바 언어에서는 상속이라는 제한이 있는 템플릿 메서드 패턴보다는 전략 패턴이 더 많이 활용된다.

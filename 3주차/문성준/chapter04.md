# ch04 자바가 확장한 객체 지향

## 다형성: 사용편의성

---

객체 지향에서 다형성이라고 하면 오버라이딩 (overriding)과 오버로딩 (overloading)이라고 할 수
있다. 물론 상위 클래스와 하위 클래스 사이에서도 다형성을 이야기할 수 있고, 인터페이스와 그것의
구현 클래스 사이에서도 다형성을 이야기할 수 있지만 가장 기본은 오버라이딩과 오버로딩이라고 할
수 있다.

### 오버라이딩? 오버로딩?

<aside>
💡 *오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의*

</aside>

### 다형성과 T메모리

![제목 없음.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6cb888ac-16f5-4b2a-9c56-643af9a11e04/%EC%A0%9C%EB%AA%A9_%EC%97%86%EC%9D%8C.png)

 오버로딩된 showName(String name), 오버라이딩된 showName()을 확인할 수 있다.

### 다형성이 지원되지 않는 언어

오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 다형성을 제공하고 이
다형성이 개발자가 프로그램을 작성할 때 사용편의성을 준다.

오버라이딩의 경우, 하위 클래스가 재정의한 메서드를 알아서 호출해 줌으로써 형변환이나 instanceof 연산자를 써서 하위 클래스가 무엇인지 신경 쓰지 않아도 된다. 상위 클래스 타입의 객체
참조 변수에서 하위 클래스가 오버라이딩한 메서드를 자동으로 호출해준다.

오버로딩은 함수명 하나를 가지고 인자 목록만 달리하면 되니 얼마나 사용하기 편리한지 알 수 있다.

예를 들자면, add라는 함수가 있을 경우. 같은 함수로 인자 타입을 다르게 준다면, 얼마나 편리하게 쓸 수 있을지 감이 올 것이다.

## 캡슐화: 정보은닉

---

자바에서 정보 은닉 （information hiding）이라고 하면 접근 제어자인 private, [default],
protected, public이 생각날 것이다.

접근 제어자가 객체 멤버 （인스턴스 멤버）와 쓰일 때와 정적 멤버 （클래스 멤버）와 함께 쓰일 때를 비교해서 살펴보자.

### 객체 멤버의 접근 제어자

속성이나 메서드 아래에 _(밑줄)을 사용한 경우는 정적 멤버를 나타낸다. ClassA의 -, ~, #, + 에 주목하라. 소스로 구현.

```java
public class ClassA {
private int pri；
int def；
protected int pro；
public int pub；
void runSomething() {}
static void runStaticThing() {}
}
```

- 상속을 받지 않았다면 객체 멤버는 객채를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.

두 번째 내용은조금 더 생각해 볼 필요가 있다.정적 멤버의 접근방법 표에 나오는 public 정적 속성인 pubSt의 경우라면 각 위치 별 객체 멤버 메서드에서 접근할 수 있는 방법은 무려 세 가지나 된다.

정적 멤버인 경우 클래스명.정적멤버 형식으로 접근해야 할 이유가 느껴질 것이다. 바로 일관된 형식
으로 접근하기 위해서다. 그리고 객체를 생성한 경우에는 객체참조변수명.정적멤버 형태로도 접근할
수도 있다

정적 멤버에 접근할 때는 객체참조변수명.정적멤버 형식으로 접근하기보다는 클래스명.정적멤버 형식으로 접근하라는 것이다.

### 참조 변수의 복사

Call By Value （값에 의한 호출）에 의해 그 값이 복사되며 두 개의 변수는 서로에게 영향을 주지
않는다.

```java
public class CallByValue {
public static void main(String[] args) {
int a = 10；
int b = a；
b = 20；
System.out.println(a)； // 10
System.out.printin(b)； // 20}}
```

변수 a에 10을 대입한 후, 변수 b에 변수 a가 가진 값을 복사하고, 다시 변수 b에 20을 할당한 것을 볼 수 있다. 이때 a가 가진 값이 단순히 b에 복사된 것이고 a와 b 변수는 아무런 관계도 없는 것을 알 수 있다.

그렇다면 기본 자료형이 아닌 객체를 저장하고 있는 객체 참조 변수를 복사하는 경우는 어떨까? 많은책에서는 이 경우 Call By Reference （참조에 의한 호출） 또는 Call By Address （주소에 의한 호출）라고 설명하면서 Call By Vahae와 다르게 설명하고 있다.

이를 c에서는 깊은 복사 얕은 복사라고도 부르는데, 주소 값에 의한 전달 및 호출이라고 생각하면 된다.

→ 이를 활용해서 ‘포인터’라는 기술을 쓴다.

# 📕 [자바 객체 지향의 원리와 이해] 3장. 자바와 객체 지향

## 📌 객체 지향은 인간 지향이다.
**객체 지향의 큰 그림**
- 세상의 모든 것은 "객체(Object)"다.
- 각각의 사물은 **고유**하다.
- 사물은 **속성**을 갖는다.
- 사물은 **행위**를 한다.

인간의 인지법은 사물을 하나하나 이해하기보다는 사물을 분류(class)해서 인해한다.
- 직립보행을 하며 말을 하는 존재를 사람이라고 분류한다.
- 연미복, 짧은 다리, 날지 못하는 새를 펭귄이라고 분류한다.
- 밤하늘에 반짝이는 사물들을 별이라고 분류한다.

![](https://velog.velcdn.com/images/pp8817/post/b1bb8b9c-82f2-4735-8392-733b803a55e1/image.png) </br>
박상민(object)라고 하는 존재는 사람이라는 분류에 속한다. 그리고 사람이라는 분류 안의 객체(object)들은 나이, 몸무게, 키 등의 속성(property)과 먹다, 자다, 울다 등의 행위(method)를 가지고 있다.

**우리가 실제 사물을 인지하고 사고하는 방식대로 객체 단위의 프로그래밍이 객체 지향에서 가능하다**

## 📌 객체 지향의 4대 특성 - 캡! 상추다
- 캡! : 캡슐화(Encapsulation): 정보 은닉(Information hiding)
- 상 : 상속화(~~Inheritance~~): 재사용
- 추 : 추상화(Abstraction): 모델링
- 다 : 다형성(Polymorphism): 사용 편의

> **~~Inheritance~~인 이유**</br>
잠시 후 다른 용어로 바뀔 예정이다.

개발자들은 이런 객체 지향에 대해서 '객체 지향을 지해하는 데 최소 3년을 걸린다'라고 말한다. </br>
이건 객체 지향을 제대로 이해하는데 걸리는 시간이 아닌 잘못된 이해를 바로잡는 데 걸리는 시간이다. </br>
**잘못된 이해의 대표적인 예는 바로 클래스와 객체의 관계는 '붕어빵틀과 붕어빵이다'라고 하는 설명이다.**
## 📌 클래스 vs 객체 = 붕어빵틀 vs 붕어빵 ??
많은 사람들과 글에서 클래스와 객체의 관계과 붕어빵틀과 붕어빵이라고 말한다. 그러나 틀린 비유이다.

> 클래스 객체명 = new 클래스();

위의 코드는 인정하고 이해되는 코드일 것이다.

> 붕어빵틀 붕어빵 = new 붕어빵틀();

그렇다면 위의 코드는 이해가 되는가?

그렇다면 붕어빵에게 붕어빵틀은 무엇일까? 붕어빵틀은 붕어빵을 만드는 팩터리다.

**클래스는 분류에 대한 개념이고, 객체는 클래스를 실체화한 것이다.**

# ⭐️ 객체 지향의 4대 특성
## 📌 추상화: 모델링

**"객체 지향의 추상화는 곧 모델링이다"**
추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이다.

(세부사항은 버리고 중요하고 공통적인 것만 취해 내가 관심있는 것에 집중하는 것)

- 객체 : 세상에 존재하는 유일무이한 사물
- 클래스 : 같은 속성과 기능을 가진 객체를 총칭하는 개념

우리는 객체를 먼저 인식하고 그 객체가 가진 특성에 따라 분류를 통해 클래스를 인식하게 된다. </br>
하지만 사물의 창조주는 "박상민"이라는 객체를 만들기 전에 클래스라는 개념을 먼저 만들었을 것이다.

우리도 객체 지향에서는 해당 애플리케이션의 창조주가 된다. </br>
애플리케이션 개발자는 클래스를 설계하기 위해 필요한 물체의 공통된 특성을 파악한다.

개발자가 "사람 클래스"를 만든다면 "먹다, 자다, 일하다, 울다, 시력, 몸무게, 나이 등" 여러 **공통된 특성**을 찾게 된다.

**하지만  과연 "사람"의 모든 특성을 나열할 필요가 있을까?**

개발자가 필요한 "사람"은 **Context(애플리케이션 경계)** 에 따라 달라질 수 있다.

**병원 애플리케이션** -> 시력, 몸무게 정보나 접수하다. 등의 기능이 필요하다.
**은행 애플리케이션** - > 시력, 몸무게 정보는 필요없고 나이, 연봉이나 이체하다. 대출하다. 등의 기능이 필요하다.

결국, IT 관점의
추상화란 구체적인 것을 분해해서 **관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합**하는 것을 말한다. </br>(**모델링**)
-> 자바는 이러한 객체 지향의 추상화를 "class 키워드"를 통해 지원하고 있다.

### ✔︎ 클래스 멤버 - 객체 멤버
클래스 변수는 해당 클래스의 모든 객체가 같은 값을 가질 때 사용하는 것이 기본이다. </br>
클래스 메서드는 객체들의 존재 여부에 관계없이 쓸 수 있는 메서드이다.

## 📌 상속: 재사용 + 확장
**상속은 계층적인 개념이 아닌 "재사용과 확장"으로 이해하는 것이 맞다** </br></br>
부모-자식 간의 관계 (X)
-> 동물은 포유류의 부모가 될 수 없다. 동물을 좀 더 세분화해서 포유류가 나올 수 있다.

**상속은 계층도가 아닌 분류도이다**
- 부모 클래스 - 자식 클래스 (x)
- 슈퍼 클래스 - 서브 클래스 (o)
- 상위 클래스 - 하위 클래스 (o)

![](https://velog.velcdn.com/images/pp8817/post/410ec4d2-176c-4ad8-b6f7-e5ae6b2451bd/image.png)

상위 클래스로 갈수록 추상화/일반화가 되고 하위 클래스로 갈수록 구체화/특수화가 진행된다.

**상속관계에서 만족해야만 하는 문장**
- 하위 클래스는 상위 클래스이다. (객체 지향 설계 5원칙 중 LSP: 리스코프 치환 법칙)

영희는 아빠가 될 수 없다. (일반화 불가)
펭귄은 동물의 역할을 수행할 수 있다. (일반화 가능)

코드로 알아보자
```
아버지 영희아빠 = new 딸();
// 딸을 낳으니 아버지 역할을 하는 영희아빠라 이름을 지었다??
```
이상하고 괴이하다.
```
동물 뽀로로 = new 펭귄();
// 펭귄을 낳으니 동물 역할을 하는 뽀로로라 이름 지었다.
```
문장이 매끄럽지는 못하지만 말은 된다.

>자바 언어에서 Inheritance(상속)라는 키워드는 존재하지 않는다.
대신 extends(확장)가 존재한다.

### ✔︎ 상속의 강력함
- 상속을 통해 최상위 클래스 Object의 특성을 물려받아 toString() 메서드를 모든 서브클래스에서 사용 가능하다.
- 구체화된 객체들을 하나의 일반화된 개념으로 사용할 수 있다.

자바는 다중 상속의 다이아몬드 문제로 인해 다중 상속을 버리고 인터페이스를 도입했다.

### ✔︎ 상속과 인터페이스
![](https://velog.velcdn.com/images/pp8817/post/6dc78851-04f2-48e4-ba30-744de8121a72/image.png)

인터페이스는 '**be able to**'와 같이 "**무엇을 할 수 있는**" 형태로 만드는 것이 좋다.

**자바 API에서의 be able to 형식의 인터페이스**
- Serializable 인터페이스: 직렬화할 수 있는
- Cloneable 인터페이스: 복제할 수 있는
- Comparable 인터페이스: 비교할 수 있는
- Runnable 인터페이스: 실행할 수 있는

**인터페이스는 클래스가 '무엇을 할 수 있다'라는 기능을 구현하도록 "강제"하게 된다.**

>퀴즈
상위 클래스는 하위 클래스에게 물려줄 특성이 많을수록 좋을까?
인터페이스는 구현을 강제할 메서드가 많을수록 좋을까?

**리스코프 치환 원칙**에 의해 상위 클래스가 풍성할수록 좋다.
**인터페이스 분할 원칙**에 의해 인터페이스 메서드는 적을수록 좋다. (자신의 책임이 아닌 것을 맡을 수 있으므로..)

## 📌 다형성: 사용 편의성
객체지향에서 다형성이라고 하면 '오버라이딩'과 '오버로딩'이라고 할 수 있다.
> 오버로딩이 다형성인지 아닌지에 대해서는 이견이 있다.

- 오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
- 오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

```java
Animal pingu = new Penguin();
```
위 코드에서 pingu의 showName() 메서드를 실행하면 Animal 객체에 의해 정의된 메서드가 아니라 Penguin 객체에 의해 **재정의된 showName 메서드가 실행된다.**

상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩한 메서드가 호출된다.
상위 클래스 참조 변수로 하위 클래스가 오버라이딩한 메서드를 사용할 수 있다.

## 📌 캡슐화: 정보 은닉
자바의 접근제어자: private, pretected(default), public
![](https://velog.velcdn.com/images/pp8817/post/a128e72f-292b-4cd2-af75-b691818c96b6/image.png)
- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 참조 변수를 통해 접근할 것
- 정적 멤버는 클래스명, 정적 멤버 형식으로만 접근하는 것이 좋다.

### ✔︎ 참조 변수의 복수
기본 자료형 변수 복사시 에는 "**Call by Value**"에 의해 복사되어 두 개의 변수가 서로에게 영향을 전혀 주지 않는다.

참조 자료형 변수는 값을 주소, 즉 포인터로 판단한다.

결국, 두 자료형 모두 복사시에 자신이 가지고 있는 값을 그대로 복사해서 넘겨준다. 그게 **값이냐 주소값이냐의 차이일 뿐이다.**

**출처** </br>
[스프링 입문을 위한 자바 객체 지향의 원리와 이해](https://search.shopping.naver.com/book/catalog/32462919817)
https://github.com/expert0226/oopinspring
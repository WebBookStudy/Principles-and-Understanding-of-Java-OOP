# ch03 자바와 객체지향

---

---

# 객체 지향은 인간 지향이다

아무리 복잡한 문제라도 작은 문제로 분할해서 하나씩 정복하다 보면 결국 해결된다는 전략인 것이다.
다시 말해, 논리적인 단위로 나누어 블록화해서 작성하자는 것이다.
이런 논리적인 단위의 블록을 함수라고 한다.

함수로 인해 객체 지향이라는 파격적인 제안이 나왔다.
우주 만물은 객체들의 합이며, 사물을 Object라고 한다.

이는 0과 1로 대변되는 기계(컴퓨터)에 맞춰 사고하던 방식을 버리고 현실세게를 인지하는 방식으로 프로그램을 만들자는 것이다.

### 객체 지향을 이해하기 위해 먼저 큰 그림을 생각

- 세상에 존재하는 모든 것은 사물, 즉 객체다.
- 각각의 사물은 고유하다.
- 사물은 속성을 갖는다.
- 사물은 행위를 한다.

객체 지향은 직관적이고 쉽고 인간적이다.

---

# 캡! 상추다 (객체 지향의 4대 특성)

객체 지향의 4대 특성 정도는 외우고 있자.

- 캡 슐화 : 정보 은닉
- 상 속 : 재사용
- 추 상화 : 모델링
- 다 형성 : 사용 편의

---

## 캡슐화

캡슐화를 설명하기 위해 많은 사람들이 붕어빵과 틀을 예시로 잡아왔다.
붕어빵틀은 붕어빵을 만드는 팩터리였던 것이다.

클래스와 객체를 구분하는 간단한 방법은 나이를 물어보는 것이다.
과연 클래스와 객체는 무엇일까?

- 사람의 나이는 몇 살인가?
- 김연아의 나이는 몇 살인가?
- 뽀로로의 나이는 몇 살인가?
- 펭귄의 나이는 몇 살인가?

??? → 사람과 펭귄은 클래스다.

클래스는 분류에 대한 개념이지 실체가 아니며, 객체는 실체다.

---

# 추상화

공통 특성/ 공통 속성 추출

### 추상화는 모델링이다

“객체 지향의 추상화는 곧 모델링이다”라는 관점은 무엇을 말하는 것일까?

> 추상화란 구체적인 것을 분해해서 관심 영역에 대한 특성만을 가지고 재조합하는 것이다.
> 

이 정의를 it 용어를 이용해 바꾼다면?

> 추상화란
구체적인 것을 분해해서 관심영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것 = 모델링
> 

세상에 존재하는 유일무이한 객체를 특성(속성 + 기능)에 따라 분류해 보니 객체를 통칭할 수 있는 집합적 개념, 즉 클래스(분류)가 나오게 된다.

- 객체는 유일무이(unique)한 사물이다.
- 클래스는 같은 특성을 지닌 여러 객체의 집합체다.

클래스를 이용해 object를 만들었다는 것을 강조할 때는 ojbect라는 표현보다는 클래스의 인스턴스라는 표현을 쓴다. (클래스의 인스턴스 = 객체)

때로는 애플리케이션 경계를 컨텍스트(Context)라고 부르기도 한다.

애플리케이션 경계를 알기 위해서는 단순한 질문 하나만 던져 보면 된다.

> “내가 창조하려는 세상은 어떤 세상인가?” ⇒ (프로그래밍적으로) “내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가”
> 

### 👉  중요 ‼️

- OOP의 추상화는 모델링
- 클래스 : 객체 = 펭귄 : 뽀로로
- 클래스 설계에서 추상화가 사용된다
- 클래스 설계를 위해서는 애플리케이션 경계부터 정해야 한다.
- 객체 지향에서 추상화의 결과는 클래스다

### 추상화의 개념을 넓게 본다면?

- 상속을 통한 추상화, 구체화
- 인터페이스를 통한 추상화
- 다형성을 통한 추상화

### 꼭 기억하자

자바는 객체 지향의 추상화를 ***class*** 키워드를 통해 지원하고 있다.

---

# ‼️ 클래스와 객체 관계 표현 ‼️

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/a25be732-2e47-4d44-b7e8-48e8f38acb10/Untitled.heic)

---

## 추상화와 T 메모리

객체가 생성돼야만 속성의 값을 저장하기 위한 메모리 공간이 스태틱 영역이 아닌 힙 영역에 할당된다.

클래스 멤버와 객체 멤버를 구분하는 키워드는 ***static***이다.

```java
Mouse mickey // Mouse 객체에 대한 참조 변수 mickey를 만든다
new Mouse()// Mouse 클래스의 인스턴스를 하나 만들어 힙에 배치한다
대입문 // Mouse 객체에 대한 주소(포인터)를 참조 변수 mickey에 할당한다
```

→ 만약 T 메모리의 3대 영역인 스태틱, 스택, 힙이 사용되는 과정을 이해하기 어렵다면, 연반추 학습을 통해 꼭 이해하자.

스택 영역에 생기는 변수들은 지역변수다.
지역 변수는 개발자가 별도로 초기화 하지 않으면 쓰레기 값을 갖게 된다.
즉, 클래스 속성과 객체 속성은 별도의 초기화를 해주지 않아도 정수형은 0, 부동소수점형은 0.0, 논리형은 false, 객체는 null로 초기화 된다는 것이다.

| 이름 | 다른 이름 | 사는곳 (T 메모리) |
| --- | --- | --- |
| static 변수 | 클래스 [멤버]속성, 정적 변수, 정적 속성… | 스태틱 영역 |
| 인스턴스 변수 | 객체 [멤버] 속성, 객체 변수… | 힙 영역 |
| local 변수 | 지역 변수 | 스택 영역(스택 프레임 내부) |

---

# 상속: 재사용 + 확장

객체 지향에서의 상속은 확장해서 사용할 수 있다는 의미다. 
다시 말해 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가하는 것이다.

상속을 (상위-하위) 클래스, (슈퍼-서브)클래스라고 표현하자.

클래스는 분류라는 의미이며, 상위 클래스 쪽으로 갈수록 추상화, 일반화됐다고 말하며, 하위 클래스 쪽으로 갈수록 구체화, 특수화됐다고 말한다.

상속 관계에서 반드시 만족해야 할 문장

> ***하위 클래스는 상위 클래스다.***
> 

이해를 돕기 위한 코드

```java
아버지 영희아빠 = new 딸();
// 딸을 낳으니 아버지 역할을 하는 영희아빠라 이름 지었다 -> ???????????

동물 뽀로로 = new 펭귄();
// 펭귄을 낳으니 동물 역할을 하는 뽀로로라 이름 지었다.
```

이제 많은 코드를 접하다 보면 `a c = new b();` 이런 코드를 많이 만날 것이다.
이를 쉽게 생각하면 “b에 포함되며 a 역할을 하는 변수 c”라고 생각하면 된다. (나만의 표현법)

---

### 상속의 강력함

`조류 bird = new 조류();`

위 처럼 구현한다면 아주 나쁜 친구다. bird라는 단어 자체가 객체보다는 클래스, 즉 분류에 가깝기 때문이다.

즉, 객체 참조 변수명은 객체스럽게, 클래스명은 클래스명답게 정하는 습관을 들이자.

- 객체와 클래스의 구분법
    - 조류의 나이는 ? 답할 수 있겠는가? 그래서 클래스다.
    - bird의 나이는 ? 역시 답하기 어렵다. 그래스 클래스다.

---

### 상속은 is a 관계를 만족해야 한다?

상속 관계의 더 명확한 영어 표현은 “is a kind of” 관계다.

- 하위 클래스 is a kind of 상위 클래스
- 펭귄 is a kind of 조류 → 펭귄은 조류의 한 분류다.
- 펭귄 is a kind of 동물 → 펭귄은 동물의 한 분류다.
- 고래 is a kind of 동물 → 고래는 동물의 한 분류다.
- 조류 is a kind of 동물 → 조류는 동물의 한 분류다.

👉 **아래 세 문장은 꼭 기억하자.**

- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

---

### 상속과 인터페이스

상속 관계가 is a kind of 관계다. 이해하기 쉽게 예제를 확인해보자.

- 상속 관계: 하위 클래스 is a kind of 상위 클래스
- 해석: 하위 클래스는 상위 클래스의 한 분류다.
- 예제: 고래는 동물의 한 분류다.

인터페이스는 상속과는 다르게 쓰는 것이 유용하다는 결론에 도달.

- 인터페이스: 구현 클래스 is able to 인터페이스
- 해석: 구현 클래스는 인터페이스할 수 있다.
- 예제: 고래는 헤엄칠 수 있다.

---

### 126page - 아주 아주 중요한 내용이니 꼭 기억

그림 3-31 보면 힙 영역에 대해 인스턴스가 같이 생긴 것을 확인할 수 있다.

이 그림을 이해하기 위해 코드도 함께 확인해보자.

---

# 다형성: 사용편의성

객체 지향에서 다형성 -  오버라이딩과 오버로딩

## 오버라이딩? 오버로딩?

<aside>
❓ 맞춰보자.
- 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
- 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

</aside>

혼동된다면 오토바이 마니아라고 가정해보자.

오토바이를 라이딩하고  싶은가? 로딩하고 싶은가? (참고로, 타는거랑 적재하는거임)

인공위성에서 내려볼 때 

- 오버라이딩은 맨 위에 올라탄 존재만 보임 → 상위 메서드 대신 외부에 노출.
- 옆으로 적재된 오버로딩은 모든 존재가 보임 → 하나 더 메서드를 구현했다고 생각.

### code

```java
pulbic void showH(){
	soutf("%s %s \n", n, h);
}

// 오버라이딩 - 재정의 : 상위클래스의 메서드와 같은 메서드 이름, 같은 인자 리스튼
public void showN(){
	sout("?");
}

// 오버로딩 - 중복정의 : 같은 메서드 이름, 다른 인자 리스트
public void showN(string yourN){
	soutf("%s %s \n", yourN, n);
}
```

### 오버로딩

함수명 하나를 가지고 인자 목록만 달리하면 되니 얼마나 사용하기 편리한지 알 수 있따.

자바 5에서 추가된 제네릭을 이용하면 하나의 함수만 구현해도 다수의 함수를 구현한 효과를 낼 수 있다.

(제네릭을 모른다면 구글링 해보는 것을 추천합니다 - 내용의 범위가 넓기 때문)

---

# 캡슐화 : 정보은닉

`protected`가 자신과 상속 관계에 있는 서브 클래스만 접근 가능한 걸로 착각하는 경우가 많은데, 
같은 패키지라면 한 집에 산다고 생각하기에 접근 가능하다는 사실도 꼭 기억하자.

다음 두 가지 사항도 기억해두자.

- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 클래스명.정적멤법 형식으로 접근하는 것을 권장한다.

139page에 있는 정적 멤버의 접근 방법 표를 보면 접근할 수 있는 방법을 알 수 있어 좋다.

---

# 참조 변수의 복사

깊은 복사와 얕은 복사다.

기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 해석하는 반면, 객체 참조 변수는 저장하고 있는 값을 주소로 해석한다는 차이다.

또한, 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 판단하고, 참조 변수는 저장하고 있는 값을 주소로 판단한다고 이해하는 것이 이해하기 더 쉽다.

### 기억할 부분

- 기본 자료형 변수는 값을 값 자체로 판단
- 참조 자료형 변수는 값을 주소, 즉 포인터로 판단
- 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다.
즉, 가지고 있는 값을 그대로 복사해서 넘겨 준다.

---

# 캡! 상추다

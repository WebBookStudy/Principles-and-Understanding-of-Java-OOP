# ch05 객체지향 설계 5원칙 - SOLID

---

---

좋은 도구가 있어도 올바르게 사용하지 않으면 요리를 만든느 작업은 고될 수밖에 없다.

즉, 객체지향 언어를 이용해 객체지향 프로그램을 올바르게 설계해 나가는 방법이나 원칙을 SOLID.

---

# SOLID

- SRP (Single Responsibility Priciple) : 단일 책임 원칙 
- 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐
- OCP (Open Close Principle) : 개방 폐쇄 원칙 
- 자신의 확장엔 열려 있고, 주변의 변화에 대해선 닫혀 있다.
- LSP (Liskov Substitution Principle) : 리스코프 치환 원칙 
- 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
- ISP (Interface Segregation Principle) : 인터페이스 분리 원칙
- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.
- DIP(Dependency Inversion Principle) : 의존 역전 원칙
- 자신보다 변하기 쉬운 것에 의존하지 마라.

SOLID는 객체 지향 4대 특성(캡!상추다) 특성을 발판으로 하고 있으며, 디자인 패턴의 뼈대이며, 스프링 프레임워크의 근간이다.

<aside>
👉 ***좋은 소프트웨어 설계란 무엇일까?***
- 결합도는 낮추고 응집도를 높이는 것은 좋은 sw 설계다.
- 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
- 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.

</aside>

---

### SOLID 정리

https://www.nextree.co.kr/p6960/

---

## SRP - 단일 책임 원칙

> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
> 

역할과 책임이 너무 많으면 불편해진다.
또한, 관계가 끊겼을 때, 해당 관계에서 역할을 맡은 객체는 더 이상 할 일이 없고 관계에 대해 더이상 뭘 할 수가 없다. 대상이 없기 떄문에. (이에 대해 책에서는 여자친구와 헤어진 남자친구를 비유로, 더 이상 챙길 일 없는 기념일과 대상이 없는 키스하기였다)

여러 설명이 있었지만, 하고 싶은 말은 “역할을 분리하라는 것이 단일 책임 원칙이다”라는 것이다.

클래스를 역할과 책임에 따라 분리해서 각각 하나의 역할과 책임만 갖게 한다면 얼마나 좋은 설계인가?
생각만해도 달콤한 향기가 난다.
만약, 속성이 SRP를 지키지 못하는 경우는? 남자는 반드시 군대를 가고, 여자는 절대로 군대를 가지않는다.
그런데 사람 클래스에서 군번 속성이 있다면 ???

→ 위반되는 것이다.
→ 이를 해결하려면 간단하다. 남자클래스와 여자클래스는 사람클래스를 상속하고 차이점만 각자 구현하면 된다.

> 데이터베이스 테이블을 설계할 때는 정규화라고 하는 과정을 거친다.
> 

예를 들어, 강아지 클래스의 소변보다() 메서드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현하려고 하기에 SRP{단일책임(행위)원칙}을 위배하고 있는 것이다.

캡! 상추다를 다시 상기해 보면 SRP와 가장 관계가 깊은 것은 바로 모델링 과정을 담당하는 추상화다.

---

## OCP - 개방 폐쇄 원칙

> 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. ⇒ (쉽게 생각하면) “자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다”
> 

메서드 위주로 설게하는 다양한 자동차가 생긴다고 하는 것은 자동차 입장에서는 자신의 확장에는 개방돼 있는 것이고, 운전자 입장에서는 주변의 변화에 폐쇄돼 있는 것이다.

OCP의 아주 좋은 예는 ***JDBC*** 다.

JDBC를 사용하는 client는 db가 오라클에서 mysql로 바뀌더라도 Connection을 설정하는 부분외에는 따로 수정할 필요가 없기 떄문이다. 또한 설정 파일로 분리해두면 더더욱 변경성에 용이하기 때문이다.

마지막으로 현실 세계의 OCP 개방 폐쇄 원칙의 사례를 하나 더 생각해보자.
편의점에서는 일일 삼교대로 직원이 교대한다. 주말에는 다른 아르바이트 직원이 근무하기도 한다.
하지만 직원이 바뀐다고 해서 손님이 구매라는 행위를 하는 데는 영향이 일절 없다.
편의점 직원 중 한명은 구매 담당자일 수도 있다.
또 다른 직원은 보안 담당자일 수도 있다. 편의점 직원이 근본적으로 판매라고 하는 행위 그자체, 즉 손님과의 인터페이스가 바꾸지 않는 한 손님의 구매라는 행위는 직원이 세부적으로 구매 담당자든, 보안 담당자든 심지어 남자에서 여자로, 학생에서 노인으로 교대한다고 해도 전~~~~~혀 영향을 받지 않는다.

만약, OCP를 무시하고 구현한다면, OOP의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.
→ OCP는 반드시 지켜야 할 원칙이라는 소리다.

> 개방 폐쇄 원칙에 대한 좋은 예로 스프링 프레임 워크도 있다.
스프링 프레임워크를 공부하다 보면 개방 폐쇄 원칙의 김연아라고 할 정도로 OCP을 교과서적으로 활용하고 있음을 확인할 수 있다.
> 

---

## LSP - 리스코프 치환 원칙

> 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다
> 

### 객체 지향에서의 상속은 분류도가 돼야 한다.

- 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
- 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.

구현되지 않은 코드가 존재할 수도 있는데, 이는 상속이 조직도나 계층도 형태로 구축된 경우다.

<aside>
❓ “인터페이스할 수 있어야 한다”라는 표현은 각 인터페이스명에 따라 읽으면 쉽게 이해할 수 있다.
- AuthoCloseable - 자동으로 닫힐 수 있어야 한다.
- Appendable - 덧붙일 수 있어야 한다.
- Cloneable - 복제할 수 있어야 한다.
- Runnable - 실행할 수 있어야 한다.

</aside>

### `아버지 춘향이 = new 딸()`

뭐야 이 코드는 ?

→ 당연하다.
아빠의 역할을 맡기고 있기 때문이다.
춘향이는 아버지형 객체 참조 변수이기에 아버지 객체가 가진 행위(메서드)를 할 수 있어야 하는데 춘향이에게 아버지의 어떤 역할을 시킬 수 있을까? → 즉, 말이 안된다는 소리다.

### `동물 뽀로로 = new 펭귄();`

→ 전혀 이상 없다.

> 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.
> 

### 분류도인 경우

하위에 존재하는 것들은 상위에 있는 것들의 역할을 하는 데 전혀 문제가 없다.

LSP의 유명한 논문이 궁금하다면, 위키피디아의 논문을 참고하면 된다.

---

## ISP - 인터페이스 분리 원칙

> 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
> 

다양한 책임을 가진 클래스를 해결하려면, (단일책임원칙_SRP)하나의 역할(책임)만 하는 다수의 클래스로 분할하는 것이다.

ISP와 SRP를 고민중이라면, 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이다.

⇒ Why? (구글링 해보기)

---

## 예제 코드를 확인하고

- 빈약한 상위 클래스를 잉요한 경우, 여기저기 형변환이 발생하면서 상속의 혜택을 제대로 누리지 못하고 있음을 볼 수 있다.
- 풍성한 상위 클래스를 이용하는 예제(5-5)와 빈약한 상위 클래스 이용(5-4) 비교할 때, 사용 불가능한 경우나 불필요한 형변환이 없음을 볼 수 있다.
만약, 소개하다 라는 기능이 둘 다 필요하다면, 사용할 수 있는 객체지향기법은 ***추상 메서드***다.

객체지향 세계에서도 현실과 같은 원리가 적용된다. 예를 들면, 소대장을 여자친구로 둔 남자라고 해도 훈련 중에는 소대원으로서의 역할만, 데이트 중에는 남친으로서의 역할만을 충실하게 수행해야한다.
쉽게 해석하면, 역할에 충실히 하고 범위가 정해져 있다는 것이다.

### 인터페이스

- 인터페이스는 그 역할에 충실한 최소한의 기능만 공개하라는 것.
- 인터페이스는 is able to (~할 수 있는)이라는 기준으로 만드는 것.

---

## DIP - 의존 역전 원칙

<aside>
👉 “자신보다 변하기 쉬운 것에 의존하지 마라”

</aside>

> 고차원 모듈은 저차원 모듈에 의존하면 안된다.
이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
> 

> 추상화된 것은 구체적인 것에 의존하면 안된다.
구체적인 것이 추상화된 것에 의존해야 한다.
> 

> 자주 변경되는 구체(Concrete) 클래스에 의존하지 마라
> 

자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.

상위 클래스일수록, 인터페이스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위클래스, 인터페이스, 추상클래스를 통해 의존하라는 것이 바로 의존역전원칙이다.

---

# Soc - 관심사의 분리

스프링은 Soc를  통해 SOLID를 극한까지 적용하고 있는 아주 좋은 프레임워크다.

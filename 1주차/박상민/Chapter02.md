# 📕 [자바 객체 지향의 원리와 이해] 2장. 자바와 절차적/구조적 프로그래밍


# ✏️ 들어가며
JVM(Java Virtual Machine)의 존재와 역할을 아는 것이 자바 개발 환경을 이해하는 데 필수적이다. JVM은 이름 그대로 가상기계이다.
현실 세계에서 컴퓨터를 구동하기 위해서는 물리적 컴퓨터인 하드웨어와 운영체제, 그리고 그 위에서 구동될 소프트웨어가 필요하다. 거기에 더해 소프트웨어를 개발할 수 있는 개발 도구가 필요하다. 자바의 가상 세계는 이러한 현실 세계를 그대로 모방한다.

![](https://velog.velcdn.com/images/pp8817/post/50d5e9dc-47c8-4efd-a669-d01c3f817708/image.png)
JDK는 자바 소스 컴파일러인 javac.exe를 포함하고 있고, JRE는 자바 프로그램 실행기인 java.exe를 포함하고 있다. 자바가 이런 구조를 선택한 이유는 기존 언어로 작성된 프로그램은 각 플랫폼용으로 배포되는 설치 파일을 따로 준비해야 했던 불편함을 없애기 위해서다.

자바 개발자는 본인이 사용 중인 플랫폼에 설치된 JVM용으로 프로그램을 작성하고 배포하면 각 플랫폼에 맞는 JVM이 중재자로서 각 플랫폼에서 프로그램을 구동하는 데 아무 문제가 없게 만들어준다.
이러한 자바의 특성을 **Write Once Run Anywhere**라고 한다.
> JDK, JRE, JVM의 원래 명칭 </br>
JDK: Java Development Kit / 자바 개발 도구</br>
JRE: Java Runtime Environment / 자바 실행 환경</br>
JVM: Java Virtual Machine / 자바 가상 기계

## 📌 자바에 존재하는 절차적/구조적 프로그래밍의 유산
객체 지향 프로그래밍은 절차적/구조적 프로그래밍의 유산이다.

### ✔︎ 절차적 프로그래밍
- **goto를 쓰지 말라**
- 자바는 goto를 예약어로 등록해둘 정도로 goto는 되도록 사용하면 안된다.

**왜?**
- goto를 사용하게 되면 프로그램의 실행 순서가 복잡해질 가능성이 있다.

### ✔︎ 구조적 프로그래밍
- **함수를 써라**

**왜?**
- 중복 코드를 한 곳에 모아서 관리할 수 있고, 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성할 수 있다.

- - -
위에서 알아본 절차적/구조적 프로그래밍의 유산은 객체 지향 프로그래밍에 남아있다.
goto문은 제어 흐름을 이동시키는 용도이고, 함수는 중복 제거와 논리를 분할하기 위한 용도이다.
- 제어: 순서도와 제어문
- 함수: 객체 지향 언어의 메서드

## 📌 코드에 따른 T 메모리 구조 변화

**T 메모리 구조**
![](https://velog.velcdn.com/images/pp8817/post/aeeef66c-f693-4602-ae6a-114030dce9aa/image.png)

```java
public class Start {
    public static void main(String[] args) {
        System.out.println("Hello OOP!!!");
    }
}
```
JRE가 main() 메소드를 확인하면 JVM을 부팅한다.
부팅된 JVM이 전처리 과정을 진행한다.

**main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들**
- java.lang 패키지를 T 메모리의 스태틱 영역에 배치한다
- import된 패키지를 T 메모리의 스태틱 영역에 배치한다.
- 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치한다.

메서드가 실행되기 위해서 스택 프레임이 스택 영역에 할당된다.
메인 메서드가 실행되기 위해선 메서드의 인자(args)를 저장할 변수 공간을 스택 프레임 맨 밑에 확보해야 한다. 메서드의 인자의 변수 공간을 할당 한다는 것이다.

![](https://velog.velcdn.com/images/pp8817/post/8a6e79d8-7ba2-44dc-92b7-62d96efbc8a6/image.png)
위처럼 T 메모리가 구성되면 main() 메소드가 실행된다.

단순 print문을 위해 JRE와 JVM은 많은 일을 처리했다.
- JRE는 자바 가상 기계인 **JVM을 부팅**
- JVM은 메모리 구조를 만들고
    - java.lang 패키지 로딩
    - 클래스 로딩
    - main() 메소드 스택 프레임 배치
    - 변수 공간 배치 등의 일을 처리한다.

메서드의 끝을 나타내는 '}'를 만나면 해당 메서드의 스택 프레임이 소멸된다.

프로그램의 시작와 끝인 main() 메서드가 끝나면 **JRE는 JVM을 종료하고 JRE 자체도 운영 체제 상의 메모리에서 사라진다.**

## 📌 변수와 메모리에 의한 T 메모리 구조 변화

```java
public class Start2 {
    public static void main(String[] args) {
        int i;
        i = 10;

        double d = 20.0;
    }
}
```
코드를 보면 우선 변수를 선언하고 이후 값을 할당하는데

main () 메서드 내의 변수인 i 선언 시 JVM이 메서드 스택 프레임 안에 밑에서부터 변수 공간을 마련하고 빈 값으로 설정된다. 이후 값을 할당하면 스택 프레임의 변수공간에도 값이 할당된다.

d는 선언과 동시에 값을 할당했지만 i와 동일하게 2개의 명령어로 봐야한다.

d도 동일하게 변수공간을 확보한 후 값을 할당한다.

![](https://velog.velcdn.com/images/pp8817/post/11aae782-3910-4667-8354-e69311fe144f/image.png)

## 📌 변수는 어디에 있을까?
변수는 스태틱 영역, 스택 영역, 힙 영역 세 곳 모두에 존재한다.
세 곳 각각의 변수는 서로 다른 목적을 가진다. 각자 이름도 지역 변수, 클래스 멤버 변수, 객체 멤버 변수로 다르다.

### ✔︎ 지역 변수
지역 변수는 스택 영역의 스택 프레임 안에서 존재한다.
따라서 스택 프레임이 사라지면 함께 사라진다.

### ✔︎ 클래스 멤버 변수
클래스 멤버 변수는 스태틱 영역에서 존재한다.
스태틱 영역에 한 번 자리 잡으면 JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다.

### ✔︎ 객체 멤버 변수
객체 멤버 변수는 힙에서 존재한다.
객체 멤버 변수들은 객체와 함께 가바지 컬렉터(Garbage Collector)라고 하는 힙 메모리 회수기에 의해 소멸한다.

## 📌 메서드 호출에 따른 T 메모리 구조 변화
```java
public static void main(String[] args) {
        int k = 5;
        int m;

        m = square(k);
    }

    private static int square(int k) {
        int result;

        k = 25;

        result = k;
        return result;
    }
}
```

square() 메서드 스택 프레임에는 반환값을 저장할 변수 공간이 맨 아래, 다음으로 인자를 저장할 변수 공간, 마지막으로 메서드의 지역 변수가 자리 잡는다.

- square() 메서드 스택 프레임을 만든다.

- main() 메서드와 square()메소드의 k는 별도의 변수 공간으로 영향을 주지 않는다
- 돌려줄 값을 가져야할 반환값 변수에 result 변수에 담긴 값이 복사 된다.
    - result 변수는 스택 프레임이 삭제되면서 함께 삭제되기 때문이다.
- main()메서드와 square() 메서드는 서로의 지역변수에 접근할 수 없다.
    - **메서드 블랙박스화**
      입력 값들과 반환값에 의해서만 메소드 사이에서 값이 전달될 뿐 서로 내부의 지역변수를 볼 수 없다는 것을 의미한다.

![](https://velog.velcdn.com/images/pp8817/post/5b5f9c85-d2d3-4adc-8741-084ea42fb3a8/image.png)

### ✔︎ 메서드 간 변수 참조가 불가한 이유

1. 고유 공간에 침범하면 문제 유발 가능성이 있다.
2. **포인터 문제**
   자바가 메소드 내부의 지역 변수의 m에 접근하려면 포인터 값을 알아야한다. **자바가 가장 환영받은 이유는 포인터가 없기 때문이다.**
3. 호출하는 메소드 내부의 지역 변수를 호출당하는 쪽에서 제어할 수 있게 코드를 만들려면 결국 포인터를 주고받아야 한다.
   포인터가 없기 때문에 메서드 스펙 프레임 사이에 변수 참조는 불가능하다.

## 📌 멀티 스레드 / 멀티 프로세스의 이해
**멀티 스레드(Multi Thread)**
멀티 스레드(Multi Thread)의 T 메모리 모델은 스택 영역을 스레드 개수만큼 분할해서 쓰는 것이다.
![](https://velog.velcdn.com/images/pp8817/post/1e19788f-24c9-48c8-b7ed-d613ff051465/image.png)
하나의 T 메모리만 사용하고 스택 영역을 스레드 개수만큼 분할해서 사용 -> 메모리 사용 적음

- - -
**멀티 스레드에서의 전역 변수 사용 문제점**
![](https://velog.velcdn.com/images/pp8817/post/09e3363e-94cf-465d-b9ee-e8dfd9542758/image.png)
스레드 1의 입장에서 갑자기 20이라는 값이 출력되는 문제 발생
- 쓰기 가능한 전역 변수를 사용하게 되면 스레드 안전성이 깨진다.
- 보완 방법: 락 (lock)을 거는 방법이 존재, 그러나 락을 거는 순간 스레드의 장점이 사라진다.

**멀티 프로세스(Multi Process)**
![](https://velog.velcdn.com/images/pp8817/post/a77c91ac-5a5a-4fba-b504-7d838e17cd55/image.png)
다수의 데이터 저장 영역, 다수의 T 메모리를 갖는 구조이다.
각 프로세스마다 각자의 T 메모리가 있고, 각자 고유의 공간으로 서로 참조 가능하다.
-> **메모리 사용이 많다.**

- - -
**출처** </br>
[스프링 입문을 위한 자바 객체 지향의 원리와 이해](https://search.shopping.naver.com/book/catalog/32462919817)</br>
https://github.com/expert0226/oopinspring



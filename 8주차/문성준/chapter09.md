---

---

# 람다가 도입된 이유 ?

빅데이터를 프로그램적으로 다룰 수 있는 방법이 필요해졌다.
그 방법의 중심에는 멀티 코어를 활용한 분산 처리, 즉 **병렬화 기술이 필요**하다.

이제 하나의 CPU 안에 다수의 코어를 삽입하는 멀티 코어 프로세서들이 등장하면서 일반 프로그래머에게도 병렬화 프로그래밍에 대한 필요성이 생기기 시작했다.

자바 8에서는 병렬화를 위해 **컬렉션(배열, List, Set, Map)**을 강화했고, 컬렉션을 더 효율적으로 사용하기 위해 **스트림(Stream)을** 강화했다.

스트림을 효율적으로 사용하기 위해 **함수형 프로그래밍**이, 함수형 프로그래밍을 위해 **람다**가, 람다를 위한 인터페이스를 **함수형 인터페이스**의 변화가 수반됐다.

즉, 자바8의 발전과 변화는 꼬리에 꼬리를 무는 것이다.

<aside>
📌 **정리**
빅데이터 지원 → 병렬화 강화 → 컬렉션 강화 → 스트림 강화 → 
람다 도입 → 인터페이스 명세 변경 → 함수형 인터페이스 도입

</aside>

---

# 람다란 무엇인가 ?

> 코드 블록
> 

기존의 **코드 블록은 반드시 메서드 내에 존재**해야만 했다.
그래서 코드 블록만 갖고 싶어도 기존에는 **코드 블록을 위해 메서드**를,
**메서드를 사용하기 위해 익명 객체**를 만들거나 하는 식이었다.

하지만 위대하게도 자바 8부터는 코드 블록을 만들기 위해 이런 수고를 할 필요가 없다.

코드 블록인 람다를 메서드의 인자나 반환값으로 사용할 수 있게 됐기 때문이다.

→ 이것의 의미는 코드 블록을 변수처럼 사용할 수 있다는 것이다.

```java
// 기존 코드 블록
psvm{
	Test test = new Test();
	Run r = test;
	r.run();
}
class Test implements Run{
	public void run(){
		sout(" 1 ");
	}
}

// 코드를 개선해서 클래스 없이 익명 객체를 만들어 사용
psvm{
	Run r = new Run(){
		public void run(){
			sout(" 2 ");
		}
	};
	r.run();
}
// 위 코드는 별도의 클래스 정의 없이 코드 블록인 메서드를 사용하고자 할 때 
// 많이 사용되던 익명 객체를 사용하는 방법이다.
// 아래 코드 자바8의 더 나은 방법, 익명 객체조차 없이 바로 코드 블록만 사용
psvm{
	Run r = () -> {
	sout("3");
	};
	r.run();
}
```

마법 같은 일이 벌어지지 않았는가 ?

1. **new Run()이 사라질 수 있었던 이유 ?**
Run 타입으로 참조 변수 r을 만들고 있으니 new Run()은 컴파일러가 알아낼 수 있다.
즉, 굳이 작성할 필요가 없다는 것이다.
2. **public void run() 메서드가 `()` 로 변경될  수 있는 이유?**
Run 인터페이스가 가진 추상 메서드가 run() 메서드 단 하나이기 때문이다.
3. **람다의 구조**
`***( 인자 목록 ) → { 로직 }***`
    
    람다에서는 로직이 단 한줄로 표기되는 경우 블록 기호 `{}` 마저 생략할 수 있다.
    
    ```java
    psvm{
    	Run r = () -> sout("4");
    	r.run();
    }
    ```
    

---

# 함수형 인터페이스

이전 코드를 보면 잘 알고 있듯 Run 인터페이스는 run()이라는 추상 메서드 하나만 가진다.

이처럼 추상 메서드를 하나만 갖는 인터페이스를 자바 8부터는 함수형 인터페이스라고 하며,
이런 함수형 인터페이스만을 람다식으로 변경할 수 있다.

```java
psvm{
	TestInterface ti = (int t) -> {return t * t; };
	
	int n = ti.run(5);
	sout(n);
}

interface TestInterface{
	public abstract int run(int count);
}
```

t가 int일 수밖에 없음을 run 메서드 정의에서 알 수 있다.
따라서 int를 생략할 수 있다. 이를 **타입 추정 기능**이라 한다.

### 간소화 과정

`(int t) -> { return t * t; }`

`(t) → { return t * t;}`

인자가 하나이고 자료형을 표기하지 않는 경우 소괄호 생략가능.

`t → { return t * t;}`

이때 return 구문도 생략해야 한다.
run()을 통해 int가 반환된다는 사실을 알 수 있기에 return을 생략해도 무방하다. 연산식 뒤에 세미클론도 삭제.

`t -> t * t` 

따라서, 전체적인 코드는

```java
psvm{
	TestInterface ti = t -> t * t;
	
	int n = ti.run(5);
	sout(n);
}
```

---

메서드 호출 인자로 람다 사용

위 예제는 람다식을 함수형 인터페이스의 참조 변수에 저장해서 사용했다.

람다식을 변수에 저장하는 것이 가능하다면 당연히 메서드의 인자로도 사용할 수 있다. 코드 블록을 메서드의 인자로 전달할 수 있다는 것이다.

```java
psvm{
	TestInterface ti = t -> t * t;
	
	do(ti);
}
public static void do(TestInterface ti){
	int n = ti.run(5);
	sout(n);
}
}
```

람다식을 단 한번만 사용한다면 굳이 변수에 할당할 필요도 없다.
따라서 아래와 같이 수정할 수 있다.

```java
psvm{
	do(t -> t * t);
}
public static void do(TestInterface ti){
	int n = ti.run(5);
	sout(n);
}
}
```

---

# 메서드 반환값으로 람다 사용

람다식(함수형 인터페이스)을 메서드의 반환값으로 사용해 보자.

```java
psvm{
	TestInterface ti = do();
	int result = ti.run(3);
	sout(result);
}
public static TestInterface do(){
	return num -> num * num;
}
}
/*
만약 해당 코드가 이해 안된다면,
디버깅 해보자. 돌려도 이해 안된다면 천천히 코드 분석을 해보면 이해하기 쉬울 것이다.
아니면, 앞 챕터를 이해하고 오면 좀더 쉽다.
아니면, 필자가 별도로 정리해둔 모던 자바 인 액션에서 람다 부분을 읽으면 도움을 받을 수 있을 것이다.
*/
```

---

# 자바 8 API에서 제공하는 함수형 인터페이스

1. `**Function<T,R>**`
    - 하나의 매개변수를 받고 결과를 반환합니다.
    - `apply(T t)` 메서드를 가집니다.
    - 용도: 객체의 변환, 매핑 등에 사용됩니다
2. `**BiFunction<T,U,R>**`
    - 두 개의 매개변수를 받고 결과를 반환합니다.
    - `apply(T t, U u)` 메서드를 가집니다.
    - 용도: 두 객체를 받아 하나의 결과를 도출할 때 사용됩니다.
3. `**Predicate<T>**`
    - 하나의 매개변수를 받고 boolean 값을 반환합니다. 주로 매개변수를 테스트하는 데 사용됩니다.
    - `test(T t)` 메서드를 가집니다.
    - 용도: 객체를 조건에 따라 필터링할 때 사용됩니다
4. `**BiPredicate<T,U>**`
    - 두 개의 매개변수를 받고 boolean 값을 반환합니다.
    - `test(T t, U u)` 메서드를 가집니다.
    - 용도: 두 객체를 조건에 따라 비교할 때 사용됩니다
5. `**Consumer<T>**`
    - 하나의 매개변수를 받고 반환값이 없습니다. 주로 매개변수를 소비하는 연산에 사용됩니다.
    - `accept(T t)` 메서드를 가집니다.
    - 용도: 객체를 소비할 때 사용되며, 주로 부작용(예: 출력)을 일으키는 연산에 사용됩니다
6. `**BiConsumer<T,U>**`
    - 두 개의 매개변수를 받고 반환값이 없습니다.
    - `accept(T t, U u)` 메서드를 가집니다.
    - 용도: 두 객체를 소비할 때 사용되며, 주로 두 객체에 대한 연산을 수행할 때 사용됩니다.
7. `**Supplier<T>**`
    - 매개변수 없이 값을 공급합니다.
    - `get()` 메서드를 가집니다.
    - 용도: 특정 타입의 객체를 생성하거나 제공할 때 사용됩니다
8. `**UnaryOperator<T>**`
    - `Function`의 특수한 형태로, 입력값과 동일한 타입의 결과를 반환합니다.
    - `apply(T t)` 메서드를 가집니다.
    - 용도: 객체에 단항 연산(예: 증감, 부정)을 수행할 때 사용됩니다.
9. `**BinaryOperator<T>**`
    - `BiFunction`의 특수한 형태로, 두 입력값과 동일한 타입의 결과를 반환합니다.
    - `apply(T t, T u)` 메서드를 가집니다.
    - 용도: 두 객체에 이항 연산(예: 덧셈, 곱셈)을 수행할 때 사용됩니다.
10. **`IntPredicate`**
- 하나의 int 값을 매개변수로 받아 boolean 값을 반환합니다.
- 용도: 기본 int 타입을 조건에 따라 필터링할 때 사용됩니다. (기본 타입 전용 함수형 인터페이스는 박싱과 언박싱을 피하기 위해 존재합니다.)

### **코드 예시: 컬렉션의 요소 필터링, 변환, 처리**

```java

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class LambdaExamples {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Jane", "Michael", "Sarah");

        // 필터링: "J"로 시작하는 이름만 필터링
        List<String> jNames = names.stream()
                                   .filter(name -> name.startsWith("J"))
                                   .collect(Collectors.toList());
        System.out.println(jNames); // [John, Jane]

        // 변환: 이름을 대문자로 변환
        List<String> uppercaseNames = names.stream()
                                           .map(String::toUpperCase)
                                           .collect(Collectors.toList());
        System.out.println(uppercaseNames); // [JOHN, JANE, MICHAEL, SARAH]

        // 처리: 각 이름을 출력
        names.forEach(name -> System.out.println("Hello, " + name + "!"));
    }
}
```

이 코드 예시는 자바 8의 스트림 API와 람다 표현식을 사용하여 컬렉션의 요소를 간결하고 직관적으로 필터링, 변환, 처리하는 방법이다.  스트림 API는 함수형 프로그래밍 스타일을 자바에 도입하여 컬렉션 처리를 강력하고 유연하게 만들어주기 때문에 꼭 알아야하는 기술이다.

---

# 컬렉션 스트림에서 람다 사용

람다는 다양한 용도가 있지만, 그 중에서도 **컬렉션 스트림을 위한 기능에 크게 초점**이 맞춰져 있다.

```java
// 1 for each 사용, 배열 첨자 사용x 코드로 변경.
psvm{
	Integer[] ages = { 20,25,18,27,30,21,19,19,34,25,34,40};

	for(int age : ages){
		if (age <20){
			System.out.format("age %d \n", age);
		}
	}
}
// 2 스트림 사용 
psvm{
	Integer[] ages = { 20,25,18,27,30,21,19,19,34,25,34,40};

	Arrays.stream(ages)
		.filter(age -> age <20)
		.forEach(age -> System.out.format("age %d \n", age));
}
```

2번 코드에서 가장 좋아진 점은 How가 아닌 What만을 지정했다는 것이다.
함수형 프로그래밍의 장점인 선언적 프로그래밍을 활용.

“How”명령이 아닌 “What”라고 선언하는 것과 같다.

<aside>
❓ 이렇게 함으로써 얻는 장점이 무엇이길래 굳이 ???
그리고 How가 아닌 What만 지정했다는게 무슨 말이란거지???

</aside>

<aside>
👉 람다를 사용한 컬렉션 스트림 처리의 접근 방식에서 "How"가 아닌 "What"에 초점을 맞춘다는 것은, **어떻게**(How) 데이터를 처리할지의 절차적인 과정을 설명하는 대신, **무엇을**(What) 하고자 하는지의 결과나 의도만을 선언적으로 표현한다는 의미이며, 이러한 접근 방식은 함수형 프로그래밍의 핵심적인 장점 중 하나다.

### **선언적 프로그래밍의 장점**

1. **가독성 향상**: 코드를 통해 개발자의 의도를 명확하게 드러낼 수 있습니다. 람다와 스트림을 사용하면, 데이터가 어떤 변환 과정을 거치는지 한눈에 파악하기 쉬워집니다. 예를 들어, **`.filter(age -> age < 20)`**는 20살 미만의 나이를 필터링한다는 의도를 직접적으로 표현합니다.
2. **유지보수 용이**: "How"보다는 "What"에 집중함으로써, 코드의 목적이 더 명확해집니다. 이는 나중에 코드를 수정하거나 확장할 때, 어떤 부분을 변경해야 하는지 쉽게 파악할 수 있게 해 줍니다.
3. **버그 감소**: 선언적 접근 방식은 코드의 복잡성을 줄여줍니다. 반복문이나 조건문 등을 직접 관리할 필요가 없기 때문에, 실수로 인한 버그가 줄어들 가능성이 높습니다.
4. **병렬 처리 용이**: 스트림 API는 병렬 처리를 간단하게 만들어 줍니다. **`.parallelStream()`**을 사용하면, 데이터 컬렉션을 여러 스레드에서 처리할 수 있으므로, 성능이 향상될 수 있습니다. 이는 "How"를 신경 쓸 필요 없이 "What"만으로도 간단히 처리할 수 있는 복잡한 작업입니다.

### **"How" vs "What"**

- **How**
전통적인 절차적 프로그래밍에서는 "어떻게" 데이터를 처리할 것인지, 즉 알고리즘의 각 단계를 명시적으로 지정합니다. 예를 들어, 반복문을 사용하여 배열을 순회하고, 조건문을 통해 특정 조건을 만족하는 요소를 찾아내는 과정 등이 이에 해당합니다.
- **What**
함수형 프로그래밍 또는 선언적 프로그래밍에서는 "무엇을" 결과로 얻고자 하는지를 표현합니다. 이 방식에서는 데이터의 흐름과 변환 과정을 높은 수준에서 기술하며, 내부적으로 데이터를 어떻게 처리할지는 신경 쓰지 않습니다. 이는 마치 SQL 질의처럼, 데이터에 대한 조작을 선언적으로 기술하는 것과 유사합니다
</aside>

---

# 마지막으로,,

개발자로서의 삶을 바꿔준 책 List

1. ***토비의 스프링*** - 스프링의 교과서
2. 스프링 4.0 (최범균) - 스프링의 참고서
3. 구글링 - 자료의 바다
4. ***MS-SQL*** (정원혁) - 데이터베이스의 개념을 잡아줌
5. ***Taeyo’s ASP*** (김태영) - 해당 저자를 웹 개발자로 만들어 줌

---
